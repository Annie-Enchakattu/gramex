# Gramex APIs are versioned. The version key is required. Currently, 1.0 is the
# only version supported.
version: 1.0

# The `app:` section defines the settings for the Tornado application.
# http://tornado.readthedocs.org/en/stable/web.html#tornado.web.Application.settings
app:
    browser: False              # Open the browser on startup
    listen:
        port: 9988              # Port to bind to. (8888 used by Jupyter)
        xheaders: True
        max_buffer_size: 1000000000
        max_header_size: 1000000000
        max_body_size: 1000000000
    settings:                   # Tornado app settings
        # default_host: 'host'  # Optional name of default host
        autoreload: False
        debug: False
        compress_response: True
        serve_traceback: True
        cookie_secret: secret-key
        key_version:
        login_url: /login
        xsrf_cookies: True
        twitter_consumer_key: ...
        twitter_consumer_secret: ...
        friendfeed_consumer_key: ...
        friendfeed_consumer_secret: ...
        google_consumer_key: ...
        google_consumer_secret: ...
        facebook_api_key: ...
        facebook_secret: ...
        autoescape: True
        compiled_template_cache: True
        template_path: .
        static_hash_cache: True
        static_path: './static'
        static_url_prefix: '/static/'

# Define system caches.
# This section MUST be before the url: section. Otherwise, the urls cannot use the cache
cache:
    memory:
        type: memory                    # A default in-memory cache

# The `url:` section maps URL patterns to handlers.
# http://tornado.readthedocs.org/en/stable/web.html#tornado.web.URLSpec
url:
    default:                            # A unique name for this handler
        priority: -1                    # Apply this pattern with low than normal priority
        pattern: /(.*)                  # All URLs beginning with /
        handler: FileHandler                        # Handler used
        kwargs:                                     # Options to the handler
            path: .                                 #   path is current dir
            default_filename: index.html            #   default filename
            index: true                             #   display the index

# The `log:` section defines the log handlers. It uses the same structure as the
# Python logging schema.
# https://docs.python.org/3/library/logging.config.html#logging-config-dictschema
log:
    version: 1
    root:
        level: DEBUG
        handlers:
            - console
    handlers:
        console:
            class: logging.StreamHandler
            level: DEBUG
            formatter: colored
        access-log:
            class: logging.handlers.TimedRotatingFileHandler
            level: INFO
            formatter: file         # save it as a CSV file
            filename: access.log    # file name to save as
            encoding: utf-8         # encoded as UTF-8
            when: W0                # rotate the log file weekly
            interval: 1             # every single week
            utc: False              # using local time zone, not UTC
            backupCount: 52         # keep only last 52 backups
            delay: true             # do not create file until called
        warn-log:
            class: logging.handlers.TimedRotatingFileHandler
            level: WARN
            formatter: file         # save it as a CSV file
            filename: warn.log      # file name to save as
            encoding: utf-8         # encoded as UTF-8
            when: W0                # rotate the log file weekly
            interval: 1             # every single week
            utc: False              # using local time zone, not UTC
            backupCount: 52         # keep only last 52 backups
            delay: true             # do not create file until called
    loggers:
        tornado.access: {}
        tornado.application: {}
        tornado.general: {}
    formatters:
        console:
            format: '%(levelname)1.1s %(asctime)s %(module)s:%(lineno)d %(message)s'
            datefmt: '%m-%b %H:%M:%S'
        colored:
            '()': colorlog.ColoredFormatter
            format: '%(log_color)s%(levelname)-8s%(reset)s%(asctime)s %(bold_yellow)s%(module)s:%(lineno)d%(reset)s %(message)s'
            datefmt: '%m-%b %H:%M:%S'
        file:
            format: '%(levelname)1.1s,%(asctime)s,%(module)s,%(lineno)d,"%(message)s"'
            datefmt: '%Y-%m-%d %H:%M:%S'

# Configure the thread pool that's shared across Gramex to run parallel threads
threadpool:
    workers: 8                  # Max number of parallel threads


# The `schedule:` section defines when specific code is to run.
#
# https://github.com/josiahcarlson/parse-crontab
schedule:
    gramex-reconfig:
        function: gramex.init           # Reload Gramex config
        minutes: '*/30'                 # Every 30 minutes
    # scheduled-message:
    #     function: logging.info          # Run this function
    #     kwargs:                         # with these keys and values
    #         msg: This is a scheduled message
    #     years: '*'                      # Every year (* is default)
    #     months: 'jan, mar-may, 12'      # In Jan, Mar, Apr, May, Dec
    #     dates: '1, L'                   # On the first and last days
    #     weekdays: '*'                   # 0-6 or SUN-SAT
    #     hours: '*/3'                    # Every 3rd hour
    #     minutes: '*/5, 59'              # Every 5th minute, and 59th minute
    #     startup: true                   # In addition, run on startup


# Define custom MIME types here
mime:
    .yml:       text/yaml
    .yaml:      text/yaml
    .md:        text/markdown
    .markdown:  text/markdown
    .json:      application/json


# Set up file watches here
# watch:
#     gramex-reconfig:
#         paths: $YAMLPATH
#         on_modified: gramex.init


# The `error:` section defines error responses. When you raise
# `GramexError(key="...")`, Gramex calls the corresponding `function:` as
# `function(handler, status_code, **kwargs)` from RequestHandler.write_error()
# `kwargs['exc_info']` will have an `exc_info` triple.
#
# http://tornado.readthedocs.org/en/latest/web.html#tornado.web.RequestHandler.write_error

# error:
#     page-not-found:
#         code: 404
#         function: SimpleErrorPage
#         kwargs:
#           h1: Page not found
#           body: This is not the page you are looking for
#     custom-error:
#         code: 500
#         function: ErrorTemplateHandler
#         path: 500.html


# The `license:` section handles the following scenarios:
# - I only want to sell only the treemap application
# - I only want SAML Auth, not OAuth
# - I only want visual, not analytic components
# - Only single user license
#
# How are services, handlers and components identified?

# license:
#     default:                    # Name of license. (Multiple licenses possible)
#         key: ...                # License key for this license
#         systems:                # Systems this license is valid for
#             system-1:           # Name of the first system
#                 method:         #   Algorithm used to compute the sysid
#                 sysid:          #   System's unique ID based on algorithm
#             system-2:           # Name of the second system
#                 method:         #   Algorithm used to compute next sysid
#                 sysid:          #   ...
#         validity:               # From when to when is the license valid
#             start: 2015-01-01 00:00:00
#             end: 2016-01-01 00:00:00
#         users: 1                # Optional: max users allowed
#         inventory:              # What's allwoed. (Values matter; keys are just labels)
#             treemap:            # Each permission is a key
#                 services:       #   Allowed services
#                     ...         #     How to define these?
#                 handlers:       #   Allowed handlers
#                     ...         #     How to define these?


# email:

# cache:
#   - Output follows HTTP caching policy. Server acts as a caching HTTP proxy.
#   - Any structure can be cached and re-used across apps
#   - Any structure can be uniquely identified, possibly served as a URL
#   - Cache management: Delete LRU (least recently used), LFU (least frequently
#     used), etc. Based on memory / disk availability.
#   - Cache storage: memory, disk (serialization)
#   - Cache expiry, re-creation
#   - Cache must be thread-safe
#   - Cache record:
#     - Namespace
#     - Last updated
#     - Context (e.g. user)
#     - Hits (how often was this record retrieved)
#     - Data
#     - How to compute the data

# - **Rendering** components to PDF, PPTX, PNG, SVG, etc.
# - **Computation workflow**
# - **Queues**: If dataframes have to be stored, for example, and we want to
#   avoid too many dataframes being stored. Or if we need a cache with a limited
#   memory usage.
